---
layout : post
title : translate bytebuddy doc
---

이 페이지는 Byte Buddy 에 정리되어 있는 document를 한국어로 번역해 보기 위해서 만든 페이지이다.
전문 번역가가 아닌 관계로 번역 용어에 대한 다름이 있을수 있음.

아래와 같은 단계로 이루어질 예정임.
1. Chrome 번역
2. 부자연스러운 번역 수정
3. 전문 번역 용어 검색
4. Review

# Byte Buddy
[github](https://github.com/raphw/byte-buddy)

번역 목표로 하는 페이지 목록
1. [Develop](https://bytebuddy.net/#/develop)
> 
1. chrome 번역- 8/22
2. - TBD
3. - TBD
4. - TBD

2. [Tutorial](https://bytebuddy.net/#/tutorial)
> 
1. - TBD
2. - TBD
3. - TBD
4. - TBD

# Develop

#Getting started
First, you need to create a copy of Byte Buddy on your local machine. Simply clone Byte Buddy's repository by using git or by cloning it directly on GitHub. Once the repository was cloned, you can build the project using Maven. From your shell, this might look something like this:

>먼저 로컬 컴퓨터에 Byte Buddy의 복사본을 만들어야 합니다. git 을 사용 하거나 GitHub에서 직접 복제 하여 Byte Buddy의 저장소 를 복제하기만 하면 됩니다. 저장소가 복제되면 Maven을 사용하여 프로젝트를 빌드할 수 있습니다. 셸에서 다음과 같이 보일 수 있습니다.

>git clone https://github.com/raphw/byte-buddy.git
>cd byte-buddy
>mvn package

Before you start to code, make sure that all test cases run successfully. This should be the case at all times for the master branch of Byte Buddy. This is hopefully confirmed by our current Travis build which currently is Byte Buddy build status and which is constantly monitoring Byte Buddy's latest state. Travis is configured to compile and test the project for the Open JDK versions 6 and 7 and the Oracle JDK versions 7 and 8. Since some of our tests are creating and loading Java classes, we make sure that the generated classes do not use a format that cannot be understood by a specific Java version. If you are making changes to Byte Buddy that directly affect the generated byte code, please make sure to sufficiently test your build using different Java versions before committing your changes. All this implies that you need to write Java code that is compatible to a Java 6 compiler. As a general rule, your code should come with a minimum test coverage of 90 percent but we prefer thorough tests over tests that only attempt to hit any line. You can always run Maven's cobertura:cobertura goal for creating a report on your code's test coverage. Byte Buddy's current test coverage is at Byte Buddy code coverage . As a more modern alternative, Byte Buddy also supports running mutation tests by running org.itest:pitest-maven:mutationCoverage from Maven. Keep however in mind that running mutation tests requires a significant amount of additional runtime compared to computing line coverage. Finally, the integration profile for Maven can be activated for scanning the code base for potential errors. This profile is always activated on the continuous integration server. The checks profile on the other hand aggregates faster-running code checks and is activated by default for any Maven build.

>코딩을 시작하기 전에 모든 테스트 케이스가 성공적으로 실행되는지 확인하십시오. 이것은 masterByte Buddy 의 분기에 항상 해당되어야 합니다 . 이것은 현재 Byte Buddy의 최신 상태를 지속적으로 모니터링하고 있는 현재 Travis 빌드에서 확인되기를 바랍니다 . Travis는 Open JDK 버전 6 및 7 및 Oracle JDK 용 프로젝트를 컴파일하고 테스트하도록 구성됩니다. 바이트 버디 빌드 상태 버전 7 및 8. 일부 테스트는 Java 클래스를 생성 및 로드하므로 생성된 클래스가 특정 Java 버전에서 이해할 수 없는 형식을 사용하지 않도록 합니다. 생성된 바이트 코드에 직접적인 영향을 주는 Byte Buddy를 변경하는 경우 변경 사항을 커밋하기 전에 다른 Java 버전을 사용하여 빌드를 충분히 테스트해야 합니다. 이 모든 것은 Java 6 컴파일러와 호환되는 Java 코드를 작성해야 함을 의미합니다. 일반적으로 귀하의 코드는 최소 90%의 테스트 범위를 포함해야 하지만 우리는 어떤 라인에도 적중하려고 시도하는 테스트보다 철저한 테스트를 선호합니다. 항상 Maven을 실행할 수 있습니다.cobertura:cobertura코드의 테스트 커버리지에 대한 보고서를 생성하기 위한 목표입니다. Byte Buddy의 현재 테스트 범위는 . 보다 현대적인 대안으로 Byte Buddy는 Maven에서 실행 하여 돌연변이 테스트 실행도 지원합니다 . 그러나 돌연변이 테스트를 실행하려면 라인 커버리지를 계산하는 것과 비교하여 상당한 양의 추가 런타임이 필요합니다. 마지막으로, 잠재적인 오류에 대해 코드 기반을 스캔하기 위해 Maven용 프로필을 활성화할 수 있습니다. 이 프로필은 지속적 통합 서버에서 항상 활성화됩니다. 반면에 프로필은 더 빠르게 실행되는 코드 검사를 집계하고 모든 Maven 빌드에 대해 기본적으로 활성화됩니다.

The project is organized in different modules. The root project byte-buddy-parent serves as a common ground for the configuration of any Byte Buddy module. The project's implementation is found in the byte-buddy-dev module. This module is configured to rely on a direct dependency onto the ASM library, thus the dev qualifier in the module's name. Because the ASM library does not guarantee to respect backwards-compatibility, the byte-buddy module repackages the ASM-dependency into Byte Buddy's own name space. In doing so, the ASM dependency is moved to net.bytebuddy.jar.asm. This dependency-free module does not define sources of its own but relies on the byte-buddy-dev module. On its build, all dependencies are resolved and a dependency-free deployment descriptor is created. Further information can be found in the section on how to define a dependency onto Byte Buddy. In order to activate this repacking, you need to run the Maven build using the extras profile which will furthermore cause the creation of artifacts for source code and javadoc. If the gpgMaven attempts to sign all artifacts. For this to be possible, the gpg plugin must be configured correctly by the signer. As another module, byte-buddy-benchmark contains a JMH benchmark for measuring Byte Buddy's runtime behavior compared to other code generation libraries. The byte-buddy-agent module supplies a Java agent that allows to enhance Byte Buddy's general API. The byte-buddy-android module contains a ClassLoadingStrategy that functions on the Android platform where byte-buddy-android-test defines a test application to apply this strategy. It is only built if the android profile is activated as building the module requires an Android SDK.

>프로젝트는 다른 모듈로 구성됩니다. 루트 프로젝트 byte-buddy-parent는 모든 Byte Buddy 모듈 구성을 위한 공통 기반 역할을 합니다. 프로젝트의 구현은 byte-buddy-dev모듈 에서 찾을 수 있습니다. 이 모듈은 ASM 라이브러리 에 대한 직접적인 종속성에 의존하도록 구성되어 있으므로 모듈 이름에 dev 한정자가 있습니다. ASM 라이브러리 않기 때문에 이전 버전과의 호환성을 존중하고 보장하지 의 byte-buddy모듈은 바이트 버디 자신의 이름 공간으로 ASM 의존성을 재 포장. 이렇게 하면 ASM 종속성이 로 이동됩니다 net.bytebuddy.jar.asm. 이 종속성 없는 모듈은 자체 소스를 정의하지 않지만byte-buddy-dev기준 치수. 빌드 시 모든 종속성이 해결되고 종속성이 없는 배포 설명자가 생성됩니다. 추가 정보는 Byte Buddy에 대한 종속성을 정의하는 방법 에 대한 섹션에서 찾을 수 있습니다 . 이 재패킹을 활성화하려면 extras프로필을 사용하여 Maven 빌드를 실행해야 하며, 이는 소스 코드 및 javadoc에 대한 아티팩트 생성을 더욱 유발합니다. gpgMaven이 모든 아티팩트에 서명을 시도하는 경우 . 이것이 가능 하려면 서명자 가 gpg 플러그인을 올바르게 구성해야 합니다 . 다른 모듈 로 다른 코드 생성 라이브러리와 비교하여 Byte Buddy의 런타임 동작을 측정하기 위한 JMH 벤치마크 byte-buddy-benchmark가 포함되어 있습니다 . NSbyte-buddy-agent모듈은 Byte Buddy의 일반 API를 향상시킬 수 있는 Java 에이전트를 제공합니다. byte-buddy-android모듈이 포함 된 ClassLoadingStrategy안드로이드 플랫폼에 기능이 byte-buddy-android-test이 전략을 적용 할 수있는 테스트 응용 프로그램을 정의합니다. android모듈을 빌드하려면 Android SDK가 필요하므로 프로필이 활성화 된 경우에만 빌드됩니다 .

#Architectural overview
Every code generation framework requires a means of reflecting over types and their members. Byte Buddy accesses type information by the TypeDescription interface. This interface offers a similar API as the Class type of the Java reflection API and it is possible to represent a loaded Java class as a type description using the TypeDescription.ForLoadedType implementation which wraps such instances. However, Byte Buddy can also be used for creating Java agents where classes need to be manipulated before being loaded. Therefore, Byte Buddy never operates on loaded types but always depends on descriptions. All description interfaces are found in the net.bytebuddy.description package.

>모든 코드 생성 프레임워크에는 유형과 해당 멤버를 반영하는 수단이 필요합니다. Byte Buddy는 TypeDescription인터페이스 를 통해 유형 정보에 액세스합니다 . 이 인터페이스는 ClassJava 리플렉션 API 의 유형 과 유사한 API를 제공하며 TypeDescription.ForLoadedType이러한 인스턴스를 래핑 하는 구현을 사용하여 로드된 Java 클래스를 유형 설명으로 나타낼 수 있습니다 . 그러나 Byte Buddy는 로드되기 전에 클래스를 조작해야 하는 Java 에이전트를 생성하는 데에도 사용할 수 있습니다. 따라서 Byte Buddy는 로드된 유형에서 작동하지 않고 항상 설명에 의존합니다. 모든 설명 인터페이스는 net.bytebuddy.description패키지에 있습니다.

Similarly, Byte Buddy describes generic types as instances of the TypeDescription.Generic interface. This interface is richer than Java's equivalent, the Type interface where Byte Buddy offers methods for dealing with all sorts of generic types. Functionality that is only supported by certain generic types throws an exception when requested for a generic type that does not support certain properties. This approach was chosen as a more concise alternative to type casting that is required by the Java language. Since most manipulations are performed by visitors, this does however not show to be a problem in practice.

>마찬가지로 Byte Buddy는 제네릭 유형을 TypeDescription.Generic 인터페이스의 인스턴스로 설명합니다 . 이 인터페이스는 TypeByte Buddy가 모든 종류의 일반 유형을 처리하기 위한 메소드를 제공 하는 인터페이스인 Java의 동등한 것보다 더 풍부 합니다. 특정 제네릭 형식에서만 지원되는 기능은 특정 속성을 지원하지 않는 제네릭 형식에 대해 요청될 때 예외를 throw합니다. 이 접근 방식은 Java 언어에서 요구하는 유형 캐스팅에 대한 보다 간결한 대안으로 선택되었습니다. 대부분의 조작은 방문자에 의해 수행되기 때문에 실제로는 문제가 되지 않습니다.

Byte Buddy builds on top of the ASM byte code parser which has become the de facto standard for byte code parsing in the Java ecosystem. ASM operates with low-level constructs, often string values that represent names and descriptors. Byte Buddy offers the StackManipulation interface to represent type-safe wrappers around such visitor commands which interact with Byte Buddy's description interfaces, extract the required values into the appropriate format and interact with ASM. Furthermore, each stack manipulation is aware of its impact on the JVM's operand stack size. This way, several stack manipulations can be combined to compute their common requirement on the minimum stack size. Several stack manipulations can be grouped to represent a ByteCodeAppender. A byte code appender represents a block of code and is required to leave the operand stack empty. Additionally, a byte code appender is required to expose the space for local variables it assigns for executing its code. Typically, a byte code appender is composed of one or several stack manipulations. All classes related to code generation are collected in the net.bytebuddy.implementation.bytecode package.

>Byte Buddy 는 Java 에코시스템에서 바이트 코드 구문 분석의 사실상 표준이 된 ASM 바이트 코드 구문 분석기 를 기반으로 합니다. ASM은 이름과 설명자를 나타내는 문자열 값인 경우가 많은 저수준 구성으로 작동합니다. Byte Buddy는 StackManipulation Byte Buddy의 설명 인터페이스와 상호 작용하고 필요한 값을 적절한 형식으로 추출하며 ASM과 상호 작용하는 방문자 명령 주위에 유형 안전 래퍼를 나타내는 인터페이스를 제공합니다 . 또한 각 스택 조작은 JVM의 피연산자 스택 크기에 미치는 영향을 알고 있습니다. 이런 식으로 여러 스택 조작을 결합하여 최소 스택 크기에 대한 공통 요구 사항을 계산할 수 있습니다. 여러 스택 조작을 그룹화하여ByteCodeAppender. 바이트 코드 추가기는 코드 블록을 나타내며 피연산자 스택을 비워 두는 데 필요합니다. 또한 코드 실행을 위해 할당한 지역 변수를 위한 공간을 노출하려면 바이트 코드 추가기가 필요합니다. 일반적으로 바이트 코드 추가기는 하나 이상의 스택 조작으로 구성됩니다. 코드 생성과 관련된 모든 클래스는 net.bytebuddy.implementation.bytecode패키지에 수집 됩니다.

Each byte code appender receives the method it is implementing as an argument to its apply method. Furthermore, it receives an ASM visitor for registering the code of the method and an instance of Implementation.Context. An implementation context allows the registration of auxiliary types. Auxiliary types represent helper types that are required to execute the method. An example of an auxiliary type would be a proxy class for invoking another method of the instrumented type as it is used by the MethodDelegation instrumentation for the @SuperCall annotation. The implementation of implementation context is one of the few mutable classes within Byte Buddy as it accompanies ASM's method visitor which is itself mutable. As implementation context is however not being exposed to the public API and should neither be exposed by a byte code appender.

>각 바이트 코드 어펜더는 구현 중인 apply메서드 를 해당 메서드에 대한 인수로 받습니다 . 또한 메소드의 코드와 의 인스턴스를 등록하기 위한 ASM 방문자를 수신합니다 Implementation.Context. 구현 컨텍스트는 보조 유형의 등록을 허용합니다. 보조 형식은 메서드를 실행하는 데 필요한 도우미 형식을 나타냅니다. 보조 유형의 예로는 MethodDelegation계측에 의해 사용되는 계측 유형의 다른 메소드를 호출하기 위한 프록시 클래스가 있습니다 .@SuperCall주석. 구현 컨텍스트의 구현은 자체적으로 변경 가능한 ASM의 메소드 방문자를 동반하므로 Byte Buddy 내에서 몇 안 되는 변경 가능한 클래스 중 하나입니다. 그러나 구현 컨텍스트는 공개 API에 노출되지 않으며 바이트 코드 추가기에 의해 노출되어서도 안 됩니다.

The top-level construct for representing a method instrumentation is the Implementation interface. Instances of this interface are required to yield a ByteCodeAppender given an instrumented type. Furthermore, implementations are given a chance to register additional methods, fields or code blocks to be run within the static initializer of the instrumented type. Finally, any implementation instance receives an instance of Implementation.Target that offers a way of accessing properties of the instrumented type that is agnostic of the way that a type is instrumented. For example, it is possible to query for a super method invocation on the instrumented type. If a user conducts a subclass instrumentation, this query returns an invocation of the actual super method. If a user conducts a type-rebasement, the implementation target implementation will however invoke the original code of the rebased method which was copied into another method of the same class.

>메서드 계측을 나타내는 최상위 구성은 Implementation인터페이스입니다. 이 인터페이스의 인스턴스는 ByteCodeAppender지정된 계측 유형 을 생성하는 데 필요 합니다. 또한 구현에는 계측 유형의 정적 이니셜라이저 내에서 실행할 추가 메서드, 필드 또는 코드 블록을 등록할 수 있는 기회가 제공됩니다. 마지막으로 모든 구현 인스턴스는 다음 인스턴스를 받습니다.Implementation.Target유형이 계측되는 방식에 관계없이 계측된 유형의 속성에 액세스하는 방법을 제공합니다. 예를 들어 계측 유형에 대한 수퍼 메소드 호출을 쿼리할 수 있습니다. 사용자가 하위 클래스 계측을 수행하는 경우 이 쿼리는 실제 수퍼 메서드 호출을 반환합니다. 사용자가 유형 리베이스를 수행하는 경우 구현 대상 구현은 동일한 클래스의 다른 메소드에 복사된 리베이스된 메소드의 원래 코드를 호출합니다.

In Byte Buddy, any type is constructed by registering properties to a DynamicType.Builder. The builder itself constructs an instance of InstrumentedType which extends TypeDescription to allow Byte Buddy's other component to reflect over the instrumented type before its creation. Furthermore, method and field implementations are registered in a FieldRegistry or MethodRegistry accordingly. Finally, all implementations are applied on their matched method descriptions by the dynamic type builder supplying all of its collected information to a TypeWriter which interacts with the ASM API for generating a class file.

>Byte Buddy에서 모든 유형은 속성을 DynamicType.Builder. 빌더 자체 는 Byte Buddy의 다른 구성 요소가 생성 전에 계측된 유형을 반영할 수 있도록 InstrumentedType확장 되는 인스턴스를 TypeDescription구성합니다. 또한 방법 및 필드 구현은 FieldRegistry또는 MethodRegistry그에 따라 등록 됩니다. 마지막으로, 모든 구현은 TypeWriter클래스 파일을 생성하기 위해 ASM API와 상호 작용 하는 모든 수집된 정보를 제공하는 동적 유형 빌더에 의해 일치하는 메소드 설명에 적용 됩니다.

#Coding conventions
Byte Buddy aims for full immutability with the exception of mutable classes for interacting with the mostly mutable ASM library. Mutable components must however be isolated to the scope of interacting with ASM and must not be exposed to an end user. Neither should such instances ever be stored as the value of a field. Furthermore, some components like for example Byte Buddy's class loaders are mutable by their nature of being class loaders. All collections within Byte Buddy should however be considered immutable and this property must also be enforced when a collection is returned from the public API.

>Byte Buddy는 대부분 변경 가능한 ASM 라이브러리와 상호 작용하기 위한 변경 가능한 클래스를 제외하고 완전한 불변성을 목표로 합니다. 그러나 변경 가능한 구성 요소는 ASM과 상호 작용하는 범위로 격리되어야 하며 최종 사용자에게 노출되어서는 안 됩니다. 그러한 인스턴스는 필드 값으로 저장되어서도 안 됩니다. 또한 Byte Buddy의 클래스 로더와 같은 일부 구성 요소는 클래스 로더의 특성으로 인해 변경 가능합니다. 그러나 Byte Buddy 내의 모든 컬렉션은 변경할 수 없는 것으로 간주되어야 하며 이 속성은 컬렉션이 공개 API에서 반환될 때도 적용되어야 합니다.

All immutable classes must implement appropriate hashCode and equals methods as object equality is an important concept for some of Byte Buddy's components. For example, any Implementation instance must only prepare the instrumented type a single time because it is not legal in Java to register a field with the same name twice. To assure this, any Implementation is checked against its equality with previous implementations that already had a chance to prepare the instrumented type. If an implementation depends on different objects internally, it is important that all these components fulfill their equality contracts. Also, any component should implement an appropriate toString method to improve debugging, especially when stack traces of users are posted on help forums. With the ObjectPropertyAssertion, Byte Buddy runs unit tests for correct implementations of all of these methods.

>모든 불변 클래스는 적절한 구현해야 hashCode하고 equals개체 평등 바이트 버디의 구성 요소 중 일부에 대한 중요한 개념이기 때문에 방법. 예를 들어, Implementation동일한 이름의 필드를 두 번 등록하는 것은 Java에서 합법적이지 않기 때문에 모든 인스턴스는 계측 유형을 한 번만 준비해야 합니다. 이를 보장하기 위해 Implementation 이미 계측된 유형을 준비할 기회가 있었던 이전 구현과 동일한지 여부를 검사합니다. 구현이 내부적으로 다른 개체에 의존하는 경우 이러한 모든 구성 요소가 동등 계약을 이행하는 것이 중요합니다. 또한 모든 구성 요소는 적절한 toString특히 사용자의 스택 추적이 도움말 포럼에 게시될 때 디버깅을 개선하는 방법입니다. 를 사용하여 ObjectPropertyAssertionByte Buddy는 이러한 모든 방법의 올바른 구현을 위해 단위 테스트를 실행합니다.

Byte Buddy is strongly object-oriented but takes some inspiration of functional design. Unfortunately, being a meta library that is used by many other library developers, Byte Buddy is bound by strong compatibility requirements and is compiled on Java 6. To mimic functions, Byte Buddy often implements interfaces by enumerations where the enumeration yields a named function. Finally, class files are used as containers for related classes rather than packages. Within a class file, it is possible to define a finer visibility scope than for top-level classes, for example by allowing for protected classes that are only to be seen by subclasses or within the class that is using another class internally. Also, when a class is not longer needed as the result of refactoring, this grouping convention makes it easy to delete all dependant code.
>Byte Buddy는 객체 지향성이 강하지만 기능적 디자인에서 영감을 얻습니다. 불행히도 Byte Buddy는 다른 많은 라이브러리 개발자가 사용하는 메타 라이브러리이므로 강력한 호환성 요구 사항에 구속되며 Java 6에서 컴파일됩니다. 기능을 모방하기 위해 Byte Buddy는 열거형이 명명된 함수를 생성하는 열거형으로 인터페이스를 구현하는 경우가 많습니다 . 마지막으로 클래스 파일은 패키지가 아닌 관련 클래스의 컨테이너로 사용됩니다. 클래스 파일 내에서 최상위 클래스보다 더 미세한 가시성 범위를 정의하는 것이 가능합니다.protected하위 클래스 또는 내부적으로 다른 클래스를 사용하는 클래스 내에서만 볼 수 있는 클래스입니다. 또한 리팩토링의 결과로 클래스가 더 이상 필요하지 않을 때 이 그룹화 규칙을 사용하면 모든 종속 코드를 쉽게 삭제할 수 있습니다.

Being a meta library, Byte Buddy tries to offer APIs that are as open to extension as possible as the scope of usage cannot be anticipated. Whenever possible, delegation is to be the preferred extension mechanism over class extension. All code is to be documented what makes this property easier to validate by automatic checks. Within Byte Buddy, it is considered a bad practice to use null as a value of a field, parameter or as a method return. An exception are the description types that mimic the Java reflection API where null values are common. As description instances are exposed to end users, it was decided that the similarity is to be considered a more important factor than consistency. All potential null values have to be documented on the method. For Byte Buddy, unchecked exceptions are to be preferred over checked exceptions.

>메타 라이브러리이기 때문에 Byte Buddy는 사용 범위를 예상할 수 없는 만큼 확장이 가능한 API를 제공하려고 합니다. 가능하면 위임은 클래스 확장보다 선호되는 확장 메커니즘입니다. 자동 검사 를 통해 이 속성을 더 쉽게 확인할 수 있도록 모든 코드 를 문서화해야 합니다. Byte Buddy 내 에서 필드 값, 매개변수 또는 메소드 리턴 으로 사용하는 것은 나쁜 습관으로 간주됩니다 . 예외는 null 값이 일반적인 Java 리플렉션 API를 모방하는 설명 유형입니다. 설명 인스턴스는 최종 사용자에게 노출되므로 일관성보다 유사성이 더 중요한 요소로 간주되기로 결정했습니다. 모든 가능성nullnull값은 메소드에 문서화되어야 합니다. Byte Buddy의 경우 확인되지 않은 예외가 확인된 예외보다 우선합니다.

#Contribute
When you have fixed a bug, simply create a pull request on GitHub. We will look into the matter as quickly as possible, once we receive the notification. Make however sure that you have accurately described your changes and the fixed issue and please provide a test case that reproduces the problem and proves that your fix is working. This makes our work much easier and we will be able to apply your patch much quicker. If you add new methods, fields or types, make sure to write some in-code documentation that describes their purpose. If you apply performance-relevant changes, please self-critically reflect those changes using the byte-buddy-benchmark suite. Finally, please note that new releases of Byte Buddy are normally developed in their own branch.

>버그를 수정했으면 GitHub 에서 pull 요청 을 생성하기만 하면 됩니다. 통지를 받는 대로 최대한 빨리 문제를 조사하도록 하겠습니다. 그러나 변경 사항과 수정된 문제를 정확하게 설명했는지 확인하고 문제를 재현하고 수정 사항이 작동 중임을 증명하는 테스트 사례를 제공하십시오. 이렇게 하면 작업이 훨씬 쉬워지고 패치를 훨씬 빨리 적용할 수 있습니다. 새로운 메소드, 필드 또는 유형을 추가하는 경우 해당 목적을 설명하는 코드 내 문서를 작성해야 합니다. 성능 관련 변경 사항을 적용하는 경우 다음을 사용하여 해당 변경 사항을 자기 비판적으로 반영하십시오.byte-buddy-benchmark모음곡. 마지막으로 Byte Buddy의 새 릴리스는 일반적으로 자체 분기에서 개발됩니다.

If you are contributing a feature, please get in touch before spending a lot of time with it such that we can discuss how your changes are meaningful at Byte Buddy's current development state. Byte Buddy is meant to steadily provide more functionality but we do not grow its feature set on the expense of its stability and code consistency. However, do not be discouraged by this announcement. If you got deep enough into Byte Buddy's source to being able to implement a new awesome feature that you want to share, you did for sure give it some thought and we will do our best to merge it into our build! Simply come talk to us and we are more than happy to welcome you on board.

>기능에 기여하는 경우 Byte Buddy의 현재 개발 상태에서 변경 사항이 어떻게 의미가 있는지 논의할 수 있도록 많은 시간을 보내기 전에 연락 하십시오. Byte Buddy는 더 많은 기능을 꾸준히 제공하기 위한 것이지만 안정성과 코드 일관성을 희생하면서 기능 세트를 확장하지 않습니다. 그러나 이 발표에 낙담하지 마십시오. 공유하고 싶은 새로운 멋진 기능을 구현할 수 있을 만큼 Byte Buddy의 소스에 대해 충분히 이해하셨다면 확실히 생각해 보셨을 것입니다. 우리는 이를 빌드에 병합하기 위해 최선을 다할 것입니다! 간단히 저희에게 말씀해 주시면 배에서 여러분을 환영합니다.

If you feel like contributing to Byte Buddy's documentation, to its description on this web page or even to the structure and design of this web page, you are absolutely welcome to do so! We deeply believe that a thorough and up-to-date documentation is the key to a successful project and we will do our best to live up to this conviction. Even minor changes are welcome as long as they improve Byte Buddy's accessibility or appearance, because in the end, this project was made for its users. Simply clone this web page which is hosted on GitHub in the project's gh-pages branch. The web page was created using angular.js and Twitter's Bootstrap.

>Byte Buddy의 문서, 이 웹 페이지의 설명 또는 이 웹 페이지의 구조와 디자인에 기여하고 싶다면 절대적으로 환영합니다! 우리는 철저하고 최신의 문서화가 성공적인 프로젝트의 열쇠라고 굳게 믿고 있으며 이 신념에 부응하기 위해 최선을 다할 것입니다. Byte Buddy의 접근성이나 외관을 개선하는 한 사소한 변경이라도 환영합니다. 이 프로젝트는 결국 사용자를 위해 만들어졌기 때문입니다. 프로젝트 gh-pages분기 의 GitHub에서 호스팅되는 이 웹 페이지를 복제하기만 하면 됩니다. 웹 페이지는 angular.js 와 Twitter의 Bootstrap을 사용하여 만들었습니다 .

#Roadmap
Byte Buddy has reached version 1.0 and is considered to be feature complete aside from two features that are not yet supported. With the release of version 1.0 a big emphasis is put on the library's stability and performance and new features are added defensively. Naturally, the evolution of the Java programming language and the byte code format will require newer releases in the future where it is the goal of Byte Buddy to offer a backwards compatible way of manipulating code for older and newer versions of Java. Java 9 support is currently still experimental. As of Java 8, Byte Buddy not currently support the following functionality:

>Byte Buddy는 버전 1.0에 도달했으며 아직 지원되지 않는 두 가지 기능을 제외하고 완전한 기능으로 간주됩니다. 버전 1.0의 릴리스와 함께 라이브러리의 안정성과 성능이 크게 강조되었으며 새로운 기능이 방어적으로 추가되었습니다. 당연히 Java 프로그래밍 언어와 바이트 코드 형식의 발전은 Byte Buddy의 목표가 이전 버전과 최신 버전의 Java에 대해 이전 버전과 코드를 조작하는 역호환 방식을 제공하는 것인 미래의 최신 릴리스가 필요합니다. Java 9 지원은 현재 아직 실험 단계입니다. Java 8부터 Byte Buddy는 현재 다음 기능을 지원하지 않습니다.

Type inference
Generic types can be inferred by the Java compiler. Byte Buddy does not currently offer such functionality. Support for type inference would allow for better validation of generic types and for implementing Assigners that consider generic type information. Unfortunately, this feature imposes a lot of work while it is of little practical use. For this reason, it is not currently implemented.

>유형 추론
제네릭 유형은 Java 컴파일러에서 유추할 수 있습니다. Byte Buddy는 현재 이러한 기능을 제공하지 않습니다. 형식 유추에 대한 지원은 제네릭 형식의 더 나은 유효성 검사와 Assigner제네릭 형식 정보를 고려 하는 구현을 허용 합니다. 불행히도, 이 기능은 실제적으로 거의 사용되지 않는 반면 많은 작업을 부과합니다. 이러한 이유로 현재 구현되지 않습니다.